# -*- coding: utf-8 -*-
"""Projeto_Final_Data_Science-01.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vmhNPkdKPFL6MoNqbwkl9Q0BzJMXdGba

#Extraindo os dados que vão ser trabalhados

Primeiramente, precisamos importas as bibliotecas do pandas para manipular dataframes e networkx para criar os grafos a partir de dataframes.
"""

import pandas as pd
import networkx as nx

"""Conseguimos um arquivo .csv com os dados dos jogos de campeonatos de League of Legends de 2014 a 2018. Colocamos no drive e lemos com o pandas para gerar essa informação dataframe."""

lol_data = pd.read_csv("https://drive.google.com/uc?authuser=0&id=18s-wCIJi4wxFQVawJezIx86M2lWVps3j&export=download")

#anos de campeonatos de lol
lol_data.Year.unique()

lol_data.head()

"""Como pode ser visto cada linha refere-se a um jogo de um dos campeonatos (League), em uma determinada temporada (Season) de um ano especifico (Year). Em que o resultado dividi-se em 1 para quem venceu e 0 para quem perdeu seja do time azul (bResult) ou vermelho (rResult)."""

lol_data.info()

"""Como cada linha representa um jogo, criamos uma coluna GameID para guardar esses valores, visto que agora precisamos alinhar em cada linha o jogo e o resultado para cada time, ou seja, é preciso ter em uma linha os jogadores do time vermelho, qual foi o jogo (GameID) e que resultado tiveram na partida (rResult), assim como do time azul. Assim, separamos e emseguida concatemos, dobrando o numero de linahs do nosso dataframe."""

#cada id representa o jogo analisado
lol_data["GameID"] = lol_data.index

lolb = lol_data[["GameID","League","Year","bResult","blueTopChamp","blueJungleChamp","blueMiddleChamp","blueADCChamp","blueSupportChamp"]]
lolr = lol_data[["GameID","League","Year","rResult","redTopChamp","redJungleChamp","redMiddleChamp","redADCChamp","redSupportChamp"]]
lolr.columns = ["GameID","League","Year","Result","TopChamp","JungleChamp","MiddleChamp","ADCChamp","SupportChamp"]
lolb.columns = ["GameID","League","Year","Result","TopChamp","JungleChamp","MiddleChamp","ADCChamp","SupportChamp"]
lolb["GameID"] = lolb["GameID"].astype(str)
lolb["GameID"] = lolb["GameID"]+"b"
lolr["GameID"] = lolr["GameID"].astype(str)
lolr["GameID"] = lolr["GameID"]+"r"
lol = pd.concat([lolb,lolr], ignore_index=True)

lol.info()

"""No dataframe original uma vitória vale 1 e uma derrota vale 0, entretanto para nossa análise de melhores jogadores levamos em conta o numero de derrotas, e assim, substituimos o 0 por -1, para que na soma que faremos adiante, uma derrota anule uma vitória do personagem no jogo."""

#aqui definimos que uma derrota de um time anula uma vitoria
lol["Result"].replace(0, -1,inplace = True)
lol.head()

"""Agora, vamos dividir os dataframes por ligas(campeonatos) e escolhemos estudar o comportamento dos jogos que ocorreram em 2017 por que ao analisarmos percebemos que tinham dados mais consistentes e mais próximos do presente ano."""

#dividindo o dataset em campeonatos de todos os anos e seasons
lol = lol.loc[lol["Year"] == 2017]
NALCS = lol.loc[lol["League"] == "NALCS"]
EULCS = lol.loc[lol["League"] == "EULCS"]
WC = lol.loc[lol["League"] == "WC"]
CBLOL = lol.loc[lol["League"] == "CBLoL"]
MSI = lol.loc[lol["League"] == "MSI"]
LCK = lol.loc[lol["League"] == "LCK"]

"""Após esse corte, temos as seguintes quantidades de jogos para estudarmos."""

#numero de jogos de cada campeonato
print(NALCS.shape[0],EULCS.shape[0],WC.shape[0],MSI.shape[0],CBLOL.shape[0],LCK.shape[0],)

"""Agora definimos uma função que separa cada jogador de cada time em uma linha com seu respectivo Line e Result para podermos analisarmos cada um."""

def set_champions(df):
    frame = { 'Champion': df["SupportChamp"], 'GameID': df["GameID"], "Result": df["Result"], "Line" : "Support"} 
    supportb= pd.DataFrame(frame)
    frame = { 'Champion': df["ADCChamp"], 'GameID': df["GameID"], "Result": df["Result"], "Line" : "ADC" } 
    ADCb= pd.DataFrame(frame)
    frame = { 'Champion': df["MiddleChamp"], 'GameID': df["GameID"], "Result": df["Result"], "Line" : "Middle" } 
    Middleb= pd.DataFrame(frame)
    frame = { 'Champion': df["JungleChamp"], 'GameID': df["GameID"], "Result": df["Result"], "Line" : "Jungle" } 
    Jungleb= pd.DataFrame(frame)
    frame = { 'Champion': df["TopChamp"], 'GameID': df["GameID"], "Result": df["Result"], "Line" : "Top" } 
    Topb= pd.DataFrame(frame)
    return pd.concat([supportb, ADCb,Middleb,Jungleb,Topb], ignore_index=True)


NALCS_champions = set_champions(NALCS)
EULCS_champions = set_champions(EULCS)
WC_champions = set_champions(WC)
CBLOL_champions = set_champions(CBLOL)
MSI_champions = set_champions(MSI)
LCK_champions = set_champions(LCK)

WC_champions.head()

"""#Configurando os dataframes

Com os dataframes definidos passamos a implemetar funções que extraiam as informações que precisamos para encontrar o melhor time.  Precisamos saber a quantidade de vitorias de cada champion, e liga-los uns aos outros de acordo com o jogo que partipam juntos. Ou seja, cada time (blue e red) possuem ligações entre os champions e um resultado de vitoria atrelado a essa ligação.

Primeiramente, faremos a contagem de vitorias de cada personagem, e para definirmos que line ele teve maior desempenho, somamos suas vitorias de acordo com a line que ele atuou no jogo. Senod que a maior pontuação define a line que o jogador é mais forte.
"""

#contando numeros de vitorias por champions em cada line
def total_victories(data):
  champions =  data.Champion.unique()
  dict_wins = {}
  
  for champion in champions:
    lines = data.loc[data["Champion"] == champion]["Line"].unique()
    dict_wins[champion] = {}
    for line in lines:
      dict_wins[champion][line] = data.loc[(data['Champion'] == champion) & (data["Line"] == line)].Result.sum()
  return dict_wins
 
all_datas_list = []
#NALCS
data_nalcs = pd.DataFrame(total_victories(NALCS_champions))
#tranposição de colunas para linhas
data_nalcs = data_nalcs.T

all_datas_list.append(data_nalcs)

#EULCS
data_eulcs = pd.DataFrame(total_victories(EULCS_champions))
#tranposição de colunas para linhas
data_eulcs = data_eulcs.T

all_datas_list.append(data_eulcs)

#WC
data_wc = pd.DataFrame(total_victories(WC_champions))
#tranposição de colunas para linhas
data_wc = data_wc.T

all_datas_list.append(data_wc)


#CBLOS
data_cblol = pd.DataFrame(total_victories(CBLOL_champions))
#tranposição de colunas para linhas
data_cblol = data_cblol.T

all_datas_list.append(data_cblol)

#MSI
data_msi = pd.DataFrame(total_victories(MSI_champions))
#tranposição de colunas para linhas
data_msi = data_msi.T

all_datas_list.append(data_msi)

#MSI
data_lck = pd.DataFrame(total_victories(LCK_champions))
#tranposição de colunas para linhas
data_lck = data_lck.T

all_datas_list.append(data_lck)

data_lck.head()

"""Acima podemos ver que Malzahar, por exemplo, somando vitorias e derrotas por cada line em que participou nos jogos dessa liga, é mais forte como Support do que Middle, mas esse personagem possui um saldo de 9 pontos de vitorias. 


Assim, a função a seguir além de tornar positivos todos os valores de pontuação (somando a cada valor o valor minimo encontrado) define o line do personagem, de acordo com o que foi dito anteriromente, e qual a pontuação total de vitorias daquele personagem.
"""

#deixando todos valores positivos, execeto NaN
def positive_values(data):
  menor_score = -min([data.ADC.min(), data.Jungle.min(), data.Middle.min(), data.Support.min(), data.Top.min()])
  data += menor_score
  #definindo o papel principal de acordo com o numero de vitorias
  data['main_line'] = data.idxmax(axis=1)
  data['total'] = data.ADC.fillna(0) + data.Jungle.fillna(0) + data.Middle.fillna(0) + data.Support.fillna(0) + data.Top.fillna(0)  
  #setando NaN com -1 para na visualiação eliminar nó menor que 0
  data.fillna(-1, inplace=True)
  
for data in all_datas_list:
  positive_values(data)

"""A seguir mostramos que em cada dataframe temos represnetantes de todos os lines possiveis."""

for data in all_datas_list:
  print(data.main_line.unique())

"""Agora, temos um dataframe que define bem cada personagem, ou seja, os nós do nossos grafos."""

for data in all_datas_list:
  data.columns = data.columns.str.lower()
  print(data.head())

"""E com o dataframe a seguir iremos definir organizar nossas arestas, pois como ja foi dito os champions estão ligados entre os demais champions do seu time em cada jogo."""

#todas colunas em lowercase
LCK_champions.columns = LCK_champions.columns.str.lower()
NALCS_champions.columns = NALCS_champions.columns.str.lower()
EULCS_champions.columns = EULCS_champions.columns.str.lower()
WC_champions.columns = WC_champions.columns.str.lower()
CBLOL_champions.columns = CBLOL_champions.columns.str.lower()
MSI_champions.columns = MSI_champions.columns.str.lower()

#cada jogo tem dois times, um vencedor e outro perdedor
WC_champions.loc[WC_champions['gameid'] == '6618b']

WC_champions.loc[WC_champions['gameid'] == '6618r']

"""Para que possamos, enfim criarmos nossos grafos, vamos fazer a lista de arestas em que terá o atributo 'result' que é o somatório de vitorias daquele vinculo entre champions.

Primeiro, usamos uma função para eliminar possiveis duplicações e tirar valores NaN, bem como para vincular os personagens entre si.
"""

column_edge = 'gameid'
column_ID = 'champion'

def create_edges_champions(df):
    # seleciona colunas, tira os NaN e duplicados
    dfclean = df[[column_ID, column_edge]].dropna(subset=[column_edge]).drop_duplicates()
   
    # Para criar conexões entre champions que têm o mesmo game
    # junte dados na coluna "ID".
    dfclean = dfclean.merge(
        df[[column_ID, column_edge,'result']].rename(columns={column_ID:column_ID+"_2"}), 
        on=column_edge)
    return dfclean

NALCS_edges = create_edges_champions(NALCS_champions)
EULCS_edges = create_edges_champions(EULCS_champions)
WC_edges = create_edges_champions(WC_champions)
CBLOL_edges = create_edges_champions(CBLOL_champions)
MSI_edges = create_edges_champions(MSI_champions)
LCK_edges = create_edges_champions(LCK_champions)

CBLOL_edges.sort_values(by=['champion'])

NALCS_edges.info()

"""Agora temos um dataframe que mostra as ligações entre os personagens, mas ainda temos que limpar, pois temos muitas repetições e precisamos organizar esse dataframe antes de gerar o grafo."""

#retiando linha que nao serão usadas (self loops e arestas repetidas, ja que é esse grafo é não direcionado)
NALCS_edges = NALCS_edges[~(NALCS_edges[column_ID]>=NALCS_edges[column_ID+"_2"])].dropna()[[column_ID, column_ID+"_2", column_edge, 'result']]
EULCS_edges = EULCS_edges[~(EULCS_edges[column_ID]>=EULCS_edges[column_ID+"_2"])].dropna()[[column_ID, column_ID+"_2", column_edge, 'result']]
WC_edges = WC_edges[~(WC_edges[column_ID]>=WC_edges[column_ID+"_2"])].dropna()[[column_ID, column_ID+"_2", column_edge, 'result']]
CBLOL_edges = CBLOL_edges[~(CBLOL_edges[column_ID]<=CBLOL_edges[column_ID+"_2"])].dropna()[[column_ID, column_ID+"_2", column_edge, 'result']]
MSI_edges = MSI_edges[~(MSI_edges[column_ID]>=MSI_edges[column_ID+"_2"])].dropna()[[column_ID, column_ID+"_2", column_edge, 'result']]
LCK_edges = LCK_edges[~(LCK_edges[column_ID]>=LCK_edges[column_ID+"_2"])].dropna()[[column_ID, column_ID+"_2", column_edge, 'result']]

NALCS_edges.head(11)

#resetando o index
NALCS_edges.reset_index(drop=True, inplace=True)
EULCS_edges.reset_index(drop=True, inplace=True)
WC_edges.reset_index(drop=True, inplace=True)
CBLOL_edges.reset_index(drop=True, inplace=True)
MSI_edges.reset_index(drop=True, inplace=True)
LCK_edges.reset_index(drop=True, inplace=True)
NALCS_edges.head()

NALCS_edges.info()

"""Apesar de eliminarmos as repetições de ligações dentros dos jogos, não o fizemos dentre os diferentes jogos como exemplificamos a seguir."""

#arestas repetidas em diferentes jogos
NALCS_edges.loc[((NALCS_edges['champion'] == 'Kalista') & (NALCS_edges['champion_2'] == "Zyra")) |
                      ((NALCS_edges['champion_2'] == 'Kalista') & (NALCS_edges['champion'] == 'Zyra'))]

"""Para isso, definimos a função a seguir que além de eliminar essas duplicidades já calcula o valor de vitorias da aresta, mas somamos esses dois valores de result, pois foram relações em difenretes jogos, entre esses champions."""

#definindo o peso da aresta como o saldo de vitorias e derrotas de cada par de champion
def update_result (df):
  champions = df.champion.unique()
  champions2 = df.champion_2.unique()
  edges_list = []
  for champion in champions:
    for champion2 in champions2:
      if(champion < champion2):
        repetidos = df.loc[((df['champion'] == champion) & (df['champion_2'] == champion2)) |
                        ((df['champion_2'] == champion) & (df['champion'] == champion2))]
        
        if(len(repetidos)>0):
          edges_list.append((champion, champion2, repetidos["result"].sum()))
          
  dfMod = pd.DataFrame(edges_list, columns=['source', 'target', 'result'])

  return dfMod

NALCS_edges = update_result(NALCS_edges)
print('NALCS_edges done.')
EULCS_edges = update_result(EULCS_edges)
print('EULCS_edges done.')
CBLOL_edges = update_result(CBLOL_edges)
print('CBLOL_edges done.')
WC_edges = update_result(WC_edges)
print('WC_edges done.')
MSI_edges = update_result(MSI_edges)
print('MSI_edges done.')
LCK_edges = update_result(LCK_edges)
print('LCK_edges done.')

"""Pronto, temos um dataframe de arestas enxuto e pronto para fazer parte de nossos grafos."""

#as arestas repetidas em jogos diferentes foram eliminadas e adicionado um peso quanto saldo de vitorias
NALCS_edges.loc[((NALCS_edges['source'] == 'Kalista') & (NALCS_edges['target'] == "Zyra")) |
                      ((NALCS_edges['target'] == 'Kalista') & (NALCS_edges['source'] == 'Zyra'))]

NALCS_edges.info()

"""#Criando os grafos

Depois de trabalharmos os dataframes para alcançarmos nosso objetivo de ter nós que representam os champions em suas lines mais relevantes junto a seu saldo de vitórias, bem como arestas que definem as ligações entre personagens que participaram em times e seus pesos definidos sobre se essa ligação teve saldo positivo de vitórias, podemos criar os grafos para analisar os resultados.
"""

#criando grafos com o dataframe de edges
source_ = 'source'
target_ = 'target'
G_NALCS = nx.from_pandas_edgelist(NALCS_edges, source=source_, target=target_, edge_attr=True)
G_EULCS = nx.from_pandas_edgelist(EULCS_edges, source=source_, target=target_, edge_attr=True)
G_WC = nx.from_pandas_edgelist(WC_edges, source=source_, target=target_, edge_attr=True)
G_CBLOL = nx.from_pandas_edgelist(CBLOL_edges, source=source_, target=target_, edge_attr=True)
G_MSI = nx.from_pandas_edgelist(MSI_edges, source=source_, target=target_, edge_attr=True)
G_LCK = nx.from_pandas_edgelist(LCK_edges, source=source_, target=target_, edge_attr=True)

G_NALCS.edges(data=True)

"""Mostramos a seguir o dataframe que usaremos para atribuir aos nos, entretanto só nos interessa a coluna 'main-line' e 'total'."""

data_nalcs.head()

#inicializando os nós com seus atributos
def set_nodes_attributes(G,nodes):
  for col in nodes.columns:
    if ((col == 'total') | (col == 'main_line')):
      nx.set_node_attributes(G, nodes[col].to_dict(),col)

  
set_nodes_attributes(G_NALCS, data_nalcs)
set_nodes_attributes(G_EULCS, data_eulcs)
set_nodes_attributes(G_WC, data_wc)
set_nodes_attributes(G_CBLOL, data_cblol)
set_nodes_attributes(G_MSI, data_msi)
set_nodes_attributes(G_LCK, data_lck)

G_NALCS.nodes(data=True)

"""Agora geramos os .graphml para manipularmos no Gephi."""

nx.write_graphml(G_NALCS, 'g_nalcs_2017.graphml')
nx.write_graphml(G_EULCS, 'g_eulcs_2017.graphml')
nx.write_graphml(G_WC, 'g_wc_2017.graphml')
nx.write_graphml(G_CBLOL, 'g_cblol_2017.graphml')
nx.write_graphml(G_MSI, 'g_msi_2017.graphml')
nx.write_graphml(G_LCK, 'g_lck_2017.graphml')

"""#Gerando visualizações"""

def size_of_nodes(G, data):
  size_list = []
  for i in G.nodes():
    size_list.append(data.loc[i]['total'].min()*30)
  return size_list

size_from_wins_cblol = size_of_nodes(G_CBLOL, data_cblol)
size_from_wins_msi = size_of_nodes(G_MSI, data_msi)
size_from_wins_wc = size_of_nodes(G_WC, data_wc)

import matplotlib.pyplot as plt
import matplotlib.image as mpimg

#CBLOL
pos = nx.circular_layout(G_CBLOL)
# larger figure size
plt.figure(3,figsize=(10,10)) 


nx.draw(G_CBLOL,pos,with_labels=True,edge_color='g',node_size =size_from_wins_cblol)
plt.show()

#MSI
pos = nx.circular_layout(G_MSI)
# larger figure size
plt.figure(3,figsize=(10,10)) 


nx.draw(G_MSI,pos,with_labels=True,edge_color='g',node_size =size_from_wins_msi)
plt.show()

#WC
pos = nx.circular_layout(G_WC)
# larger figure size
plt.figure(3,figsize=(10,10)) 


nx.draw(G_WC,pos,with_labels=True,edge_color='g',node_size =size_from_wins_wc)
plt.show()

!pip install nxviz

# Import necessary modules to use Circos plot
import matplotlib.pyplot as plt
from nxviz import CircosPlot

# Create the CircosPlot object - CBLOL
c = CircosPlot(G_CBLOL,
               node_size = size_from_wins_cblol,
               node_labels=True,
               figsize = (15,15),
               nodeprops={"radius": 0.5},
               fontsize=12
               )

# Draw c to the screen
c.draw()
c.figure.tight_layout()

# Display the plot

plt.show()

# Create the CircosPlot object - MSI
m = CircosPlot(G_MSI,
               node_size = size_from_wins_msi,
               node_labels=True,
               figsize = (15,15),
               nodeprops={"radius": 0.5},
               fontsize=12
               )

# Draw c to the screen
m.draw()
m.figure.tight_layout()

# Display the plot

plt.show()

# Create the CircosPlot object - WC
w = CircosPlot(G_WC,
               node_size = size_from_wins_wc,
               node_labels=True,
               figsize = (15,15),
               nodeprops={"radius": 0.5},
               fontsize=12
               )

# Draw c to the screen
w.draw()
w.figure.tight_layout()

# Display the plot

plt.show()

"""#Criandos Grafos Gephi

A fim de gerar grafos para analise do time perfeito, fizemos usa da ferramenta Gephi, em que configuramos os dados da seguinte forma:


*   Tamanho do Nó: Ranking de acordo com total (de vitorias do champion)
*   Cor do Nó: Partition de acordo com a main_line (line principal do champion)
*   Cor das Arestas: Ranking de acordo com result (peso de vitorias da ligação par a par)
*   Filtro: Intervalo result (arestra) > 0
*   Distribuição: Fruchterman-Reingold

Legenda para saber o significado de cada cor, mas deve-se ignorar as porcentagens nos grafos MSI e WC.

![MSI](https://drive.google.com/uc?authuser=0&id=1dZVxmbCEW-pxY6E0hzYSCBAvHjUbSLap&export=download)

CBLOL

![cblol](https://drive.google.com/uc?authuser=0&id=10SEEJwWYcviOwXhTFjVDH_AzzQOIMU2C&export=download)

MSI

![MSI](https://drive.google.com/uc?authuser=0&id=1y-u6uCp5d4halM4Brw6tFwv-RdKwAmDl&export=download)

WC
![WC](https://drive.google.com/uc?authuser=0&id=1Cl8SUMv2qZd6y1qZFarklN4W3HXjjeqW&export=download)

# Analisando métricas dos jogos
"""

CBLOL.head()

CBLOL["TopChamp"].value_counts().reset_index().head(10)

def make_df_with_pick(df):
    MyEmptydf = pd.DataFrame()
    lines = ["TopChamp","JungleChamp","MiddleChamp","ADCChamp","SupportChamp"]
    for line in lines:
        temp_df = df[line].value_counts().reset_index()
        frame = { line: temp_df["index"], line[:-5]+'Picks': temp_df[line]} 
        frame = pd.DataFrame(frame)
        frame[line[:-5]+'Picks'].apply(int)
        MyEmptydf = pd.concat([MyEmptydf,frame], axis = 1)
    return MyEmptydf
NALCS_TOPS = pd.DataFrame(make_df_with_pick(NALCS))
EULCS_TOPS = pd.DataFrame(make_df_with_pick(EULCS))
WC_TOPS = pd.DataFrame(make_df_with_pick(WC))
CBLOL_TOPS = pd.DataFrame(make_df_with_pick(CBLOL))
MSI_TOPS = pd.DataFrame(make_df_with_pick(MSI))
LCK_TOPS = pd.DataFrame(make_df_with_pick(LCK))

CBLOL_TOPS.head()

def picks(df,league):
    print("")
    print(league.upper())
    print("")
    lines = ["TopChamp","JungleChamp","MiddleChamp","ADCChamp","SupportChamp"]
    for line in lines:
        print("")
        print(line.upper())
        print("")
        for index, row in df.head().iterrows():
            display(Image(url= "https://ddragon.leagueoflegends.com/cdn/9.12.1/img/champion/"+row[line]+".png", width=60, height=60))
            print(str(row[line]))
            print("PICKS: " + str(row[line[:-5]+"Picks"]))
    display()
picks(NALCS_TOPS,"NALCS 2017")
picks(EULCS_TOPS,"EULCS 2017")
picks(WC_TOPS,"WC 2017")
picks(CBLOL_TOPS,"CBLOL 2017")
picks(MSI_TOPS,"MSI 2017")
picks(LCK_TOPS,"LCK 2017")

k = result_LCK.sort_values(by=['total','champion'],ascending = False)
k.loc[k["main_role"] == "total"]